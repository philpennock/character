// Copyright Â© 2015,2021 Phil Pennock.
// All rights reserved, except as granted under license.
// Licensed per file LICENSE.txt

//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"slices"
	"sort"
	"strconv"
	"strings"

	"github.com/philpennock/character/internal/runemanip"
)

const HTTP_USER_AGENT = "update_entities/0.1 (GH repo philpennock/character; @philpennock if issues)"

func processEntityDirTo(entityFiles []string, outfile string, pkg, mapName string) error {
	entities := make(map[string]rune)
	runes := make(map[rune][]string)

	matcher := regexp.MustCompile(strings.Replace(
		`^\s* \<\!ENTITY \s+ (\S+) \s+ (?:CDATA \s+)? "\&\#([Xx]?)([0-9a-fA-F]+);"`,
		" ", "", -1))

	var lastErr error
	for _, infile := range entityFiles {
		file, err := os.Open(infile)
		if err != nil {
			fmt.Fprintf(os.Stderr, "process: %s\n", err)
			lastErr = err
			continue
		}
		scanner := bufio.NewScanner(file)

		for scanner.Scan() {
			got := matcher.FindSubmatch(scanner.Bytes())
			if got == nil {
				continue
			}
			entity := string(got[1])
			var r rune
			if len(got[2]) > 0 {
				r = runemanip.RuneFromHexField(got[3])
			} else {
				i64, err := strconv.ParseInt(string(got[3]), 10, 32)
				if err != nil {
					fmt.Fprintf(os.Stderr, "parsing entity %q failed to parse int: %s\n", entity, err)
					continue
				}
				r = rune(i64)
			}
			if have, ok := entities[entity]; ok {
				if have != r {
					fmt.Fprintf(os.Stderr, "duplicate entity definition; %q have %x so ignoring %x\n", entity, have, r)
				}
			} else {
				entities[entity] = r
			}
			if have, ok := runes[r]; ok {
				dup := slices.Contains(have, entity)
				if !dup {
					runes[r] = append(runes[r], entity)
				}
			} else {
				runes[r] = []string{entity}
			}
		}

		if err := scanner.Err(); err != nil {
			fmt.Fprintf(os.Stderr, "scanning %q: %s\n", infile, err)
			if lastErr == nil {
				lastErr = err
			}
		}
		if err := file.Close(); err != nil {
			fmt.Fprintf(os.Stderr, "close(%q): %s\n", infile, err)
			if lastErr == nil {
				lastErr = err
			}
		}
	}
	if lastErr != nil {
		return lastErr
	}

	fh, err := os.Create(outfile)
	if err != nil {
		return err
	}

	entityKeys := make([]string, 0, len(entities))
	for k := range entities {
		entityKeys = append(entityKeys, k)
	}
	sort.Strings(entityKeys)
	// will be weirdly sorted for runes with top bit set:
	runeKeys := make([]int, 0, len(runes))
	for k := range runes {
		runeKeys = append(runeKeys, int(k))
	}
	sort.Ints(runeKeys)

	// This is a semi-standard; auto-generated code should contain a line matching:
	//    ^// Code generated .* DO NOT EDIT\.$
	// per <https://golang.org/s/generatedcode>.
	// Additionally, to better avoid bikeshedding, comply with earlier suggestions
	// to have that be the first line of an N>=1 line `//` comment, coming before
	// both the `package` declaration and any `/*...*/` comments.
	fmt.Fprintf(fh, "// Code generated by util/update_entities.go; DO NOT EDIT.\n\n")

	fmt.Fprintf(fh, "package %s\n\n// %s %s\nvar %s = map[string]rune{\n",
		pkg,
		mapName, "maps those names to Unicode codepoints",
		mapName)
	for _, ent := range entityKeys {
		fmt.Fprintf(fh, "\t\"%s\": %d,\n", ent, entities[ent])
	}
	fmt.Fprintf(fh, "}\n\n// %sReverse %s %s\nvar %sReverse = map[rune][]string{\n",
		mapName, "maps Unicode codepoints to", mapName,
		mapName)
	for _, runeI := range runeKeys {
		fmt.Fprintf(fh, "\t%d: []string{\"%s\"},\n", runeI, strings.Join(runes[rune(runeI)], "\", \""))
	}
	fmt.Fprintf(fh, "}\n\n// EOF\n")

	err = fh.Close()
	if err != nil {
		return err
	}

	fmt.Printf("Cleaning up file with go fmt: ")
	cleanup := exec.Command("go", "fmt", outfile)
	cleanup.Stdout = os.Stdout
	cleanup.Stderr = os.Stderr
	return cleanup.Run()
}

type WhatWGEntity struct {
	Codepoints []int  `json:"codepoints"`
	Characters string `json:"characters"`
}

type WhatWGEntityMap map[string]WhatWGEntity

func processWhatWGEntitiesJSON(sourceURL string, outfile string, pkg, mapName string) error {
	entities := make(WhatWGEntityMap, 3000)
	runes := make(map[rune][]string, 3000)

	client := http.DefaultClient
	ctx := context.Background()
	req, err := http.NewRequestWithContext(ctx, "GET", sourceURL, nil)
	if err != nil {
		return err
	}
	req.Header.Add("User-Agent", HTTP_USER_AGENT)
	req.Header.Add("Accept", "application/json")
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	dec := json.NewDecoder(resp.Body)
	if err = dec.Decode(&entities); err != nil {
		return err
	}

	fh, err := os.Create(outfile)
	if err != nil {
		return err
	}

	entityKeys := make([]string, 0, len(entities))
	for k := range entities {
		entityKeys = append(entityKeys, k)
	}
	sort.Strings(entityKeys)

	// This is a semi-standard; auto-generated code should contain a line matching:
	//    ^// Code generated .* DO NOT EDIT\.$
	// per <https://golang.org/s/generatedcode>.
	// Additionally, to better avoid bikeshedding, comply with earlier suggestions
	// to have that be the first line of an N>=1 line `//` comment, coming before
	// both the `package` declaration and any `/*...*/` comments.
	fmt.Fprintf(fh, "// Code generated by util/update_entities.go; DO NOT EDIT.\n// Origin: %q\n\n", sourceURL)

	fmt.Fprintf(fh, "package %s\n\n// %s %s\nvar %s = map[string]rune{\n",
		pkg,
		mapName, "maps those names to Unicode codepoints",
		mapName)
	for _, ent := range entityKeys {
		var ourName string
		if !strings.HasSuffix(ent, ";") {
			continue
		}
		if strings.HasPrefix(ent, "&") {
			ourName = strings.TrimRight(ent[1:], ";")
		} else {
			ourName = strings.TrimRight(ent, ";")
		}
		cp := rune(entities[ent].Codepoints[0])
		fmt.Fprintf(fh, "\t\"%s\": %d,\n", ourName, cp)
		if prior, ok := runes[cp]; ok {
			runes[cp] = append(prior, ourName)
		} else {
			runes[cp] = []string{ourName}
		}
	}

	runeKeys := make([]int, 0, len(runes))
	for k := range runes {
		runeKeys = append(runeKeys, int(k))
	}
	sort.Ints(runeKeys)

	fmt.Fprintf(fh, "}\n\n// %sReverse %s %s\nvar %sReverse = map[rune][]string{\n",
		mapName, "maps Unicode codepoints to", mapName,
		mapName)
	for _, runeI := range runeKeys {
		fmt.Fprintf(fh, "\t%d: []string{\"%s\"},\n", runeI, strings.Join(runes[rune(runeI)], "\", \""))
	}
	fmt.Fprintf(fh, "}\n\n// EOF\n")

	err = fh.Close()
	if err != nil {
		return err
	}

	fmt.Printf("Cleaning up file with go fmt: ")
	cleanup := exec.Command("go", "fmt", outfile)
	cleanup.Stdout = os.Stdout
	cleanup.Stderr = os.Stderr
	return cleanup.Run()
}

var setOfEntities = []struct {
	outfile         string
	mapName         string
	jsonURL         string
	inDirCandidates []string
}{
	{
		"entities/generated_html.go",
		"HTMLEntities",
		"https://html.spec.whatwg.org/entities.json",
		[]string{
			"/usr/local/share/sgml/html/4.01", // FreeBSD textproc/html
			"/opt/local/share/OpenSP",         // MacOS(MacPorts)
			"/usr/share/sgml/html/entities",   // Debian/Ubuntu
			"/System/Library/PrivateFrameworks/CoreProfile.framework/Versions/A/Resources/Devices", // MacOS
			// note that the files are copyright ISO, not Apple property, so okay to parse them for making our derived code
		},
	},
	{
		"entities/generated_xml.go",
		"XMLEntities",
		"",
		[]string{
			"/usr/local/share/xml/xmlcharent",                    // FreeBSD textproc/xmlcharent
			"/opt/local/share/xml/docbook/*/ent",                 // MacOS(MacPorts)
			"/usr/share/xml/entities/xml-iso-entities-8879.1986", // Debian/Ubuntu
			"/usr/local/Cellar/docbook/*/docbook/xml/*/ent",      // MacOS(homebrew:docbook)
		},
	},
}

// Also: sgml-data gives us /usr/share/sgml/entities/sgml-iso-entities-${versions_list}/ dirs

func findExistingCandidate(list []string) (entityFiles []string) {
	for _, dirOrGlob := range list {
		if strings.ContainsRune(dirOrGlob, '*') {
			dirList, err := filepath.Glob(dirOrGlob)
			if err != nil || dirList == nil {
				continue
			}
			// FIXME: we're assuming version numbers which don't change number
			// of digits (ie that lexicographic sort is also numeric sort).
			// Fix if we ever reach HTML10 or docbook 10.
			sort.Strings(dirList)
			for i := len(dirList) - 1; i >= 0; i-- {
				dir := dirList[i]
				matches, err := filepath.Glob(dir + "/*.ent")
				if err == nil && matches != nil {
					return matches
				}
			}
		} else {
			matches, err := filepath.Glob(dirOrGlob + "/*.ent")
			if err == nil && matches != nil {
				return matches
			}
		}
	}
	return nil
}

func main() {
	for _, s := range setOfEntities {
		if s.jsonURL != "" {
			if err := processWhatWGEntitiesJSON(s.jsonURL, s.outfile, "entities", s.mapName); err != nil {
				fmt.Fprintf(os.Stderr, "making %s: %s\n", s.mapName, err)
				os.Exit(1)
			}
			continue
		}
		entityFiles := findExistingCandidate(s.inDirCandidates)
		if entityFiles == nil {
			fmt.Fprintf(os.Stderr, "unable to find an input dir for %s\n", s.mapName)
			os.Exit(1)
		}
		if err := processEntityDirTo(entityFiles, s.outfile, "entities", s.mapName); err != nil {
			fmt.Fprintf(os.Stderr, "making %s: %s\n", s.mapName, err)
			os.Exit(1)
		}
	}
}
