// Copyright © 2020 Phil Pennock.
// All rights reserved, except as granted under license.
// Licensed per file LICENSE.txt

//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"unicode/utf8"
)

var flags struct {
	outDir              string
	locale              string
	unstable            bool
	minComposeFetchSize uint64
	noFetch             bool
	packageName         string
	noFmt               bool
}
var warningCount int

const (
	x11ComposeURLBase = "https://gitlab.freedesktop.org/xorg/lib/libx11/-/raw/master/nls/"
	x11DefaultLocale  = "en_US.UTF-8"
	x11RemoteFilename = "Compose.pre"
	x11GoFilename     = "generated_x11_compose.go"
)

func init() {
	flag.StringVar(&flags.locale, "x11-locale", x11DefaultLocale, "X11 locale to use")
	flag.Uint64Var(&flags.minComposeFetchSize, "min-x11-fetchsize", 400*1024, "minimum size of Compose to not be an error")
	flag.StringVar(&flags.outDir, "output-dir", "sources", "directory to create files in")
	flag.StringVar(&flags.packageName, "package", "sources", "package to name generated files")
	flag.BoolVar(&flags.noFetch, "no-fetch", false, "do not retrieve current files, regenerate from local only")
	flag.BoolVar(&flags.noFmt, "no-fmt", false, "do not run go fmt automatically")
}

func main() {
	flag.Parse()

	if !haveDir(flags.outDir) {
		Die("missing directory %q", flags.outDir)
	}

	x11ComposeURL := x11ComposeURLBase + flags.locale + "/" + x11RemoteFilename
	x11RawFilename := strings.Join([]string{"Compose", flags.locale, "txt"}, ".")
	x11RawOutPath := filepath.Join(flags.outDir, x11RawFilename)
	x11GenOutPath := filepath.Join(flags.outDir, x11GoFilename)

	if !flags.noFetch {
		if err := fetchURLtoFile(x11ComposeURL, x11RawOutPath, flags.minComposeFetchSize); err != nil {
			Die("fetching %q from %q failed: %s", x11RawOutPath, x11ComposeURL, err)
		}
	}

	if err := generateComposeFromTo(x11RawOutPath, x11GenOutPath); err != nil {
		Die("Generating %q from %q failed: %s", x11RawOutPath, x11GenOutPath, err)
	}

	if !flags.noFmt {
		if err := reformatFile(x11GenOutPath); err != nil {
			Die("Running go fmt failed: %s", err)
		}
	}

	if warningCount > 0 {
		Warn("encountered %d warnings", warningCount)
		os.Exit(1)
	}
}

func fetchURLtoFile(url, outpath string, minSize uint64) (err error) {
	out, err := os.Create(outpath)
	if err != nil {
		return err
	}
	defer func() {
		e := out.Close()
		if err == nil {
			err = e
		}
	}()
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	copied, err := io.Copy(out, resp.Body)
	if err != nil {
		return err
	}
	if copied < 0 || uint64(copied) < minSize {
		return fmt.Errorf("copied too little data, only %d octets, need at least %d", copied, minSize)
	}
	Trace("Updated %q from %q, size %d", outpath, url, copied)
	return nil
}

func generateComposeFromTo(inFn, outFn string) error {
	in, err := os.Open(inFn)
	if err != nil {
		return err
	}
	defer in.Close()

	composes, err := parseCompose(in)
	if err != nil {
		return err
	}

	Trace("have %d compose sequences", len(composes))
	composeMap, orderedKeys := normalizeComposes(composes)
	Trace("have %d distinct runes resulting from composes", len(orderedKeys))

	out, err := os.Create(outFn)
	if err != nil {
		return err
	}
	defer func() {
		e := out.Close()
		if err == nil {
			err = e
		}
	}()

	fmt.Fprintf(out, "// Code generated by %s; DO NOT EDIT.\n", filepath.Base(os.Args[0]))
	fmt.Fprintf(out, "\npackage %s\n\n", flags.packageName)

	// We don't want to init a map, Go is a bit slow
	fmt.Fprintf(out, "const staticX11ComposeSeqs = `\n")
	for _, r := range orderedKeys {
		keySequences := make([]string, len(composeMap[r]))
		for i, cs := range composeMap[r] {
			keySequences[i] = cs.in
		}
		replacement := strings.Join(keySequences, " ")
		fmt.Fprintf(out, "%d\t%v\n", r, strings.Replace(replacement, "`", "`+\"`\"+`", -1))
	}
	fmt.Fprintf(out, "`\n")
	fmt.Fprintf(out, "const staticX11RuneCount = %d\n", len(orderedKeys))
	fmt.Fprintf(out, "const X11Locale string = %q\n", flags.locale)

	return nil
}

type handleCounts struct {
	compose                 int
	dead, other, alias      int
	unhandled, malformed    int
	multiRune, rawUnicodeIn int
}

func parseCompose(in io.Reader) ([]composeSet, error) {
	// Given a line like:
	//   <Multi_key> <acute> <dead_horn> <o>     : "ớ"   U1EDB # LATIN SMALL LETTER O WITH HORN AND ACUTE
	// * the keys after <Multi_key> can be N long
	// * the comment is optional
	// * the identifier before the comment is optional and is often a descriptive name, not a hex encoding
	// * only the rune inside the quotes matters ... and it's unclear if it might be a multi-rune sequence.
	//
	// Comments are lines starting `XCOMM`
	// The line is a sequence of X11 keysyms and need not start `<Multi_key>`,
	// that's just the name for Compose.  Other entries will likely be dead keys.

	results := make([]composeSet, 0, 10000)
	var counts handleCounts

	rdr := bufio.NewReader(in)
	lineNum := 0
	inMultiLineComment := false
ReadLoop:
	for {
		line, err := rdr.ReadBytes('\n')
		lineNum++
		if err != nil {
			switch err {
			case io.EOF:
				break ReadLoop
			default:
				return nil, err
			}
		}

		line = bytes.TrimSpace(line)
		if len(line) == 0 {
			continue
		}
		if inMultiLineComment {
			if i := bytes.Index(line, []byte("*/")); i > -1 {
				inMultiLineComment = false
				line = line[i+2:]
				if len(line) == 0 {
					continue
				}
			} else {
				continue
			}
		}
		if bytes.HasPrefix(line, []byte("XCOMM")) {
			continue
		}
		for i := bytes.Index(line, []byte("/*")); i > -1; {
			if j := bytes.Index(line[i:], []byte("*/")); j > -1 {
				if i == 0 && i+j+2 == len(line) {
					// Trace("line %d completely removed", lineNum)
					continue ReadLoop
				}
				replacement := make([]byte, i+len(line[i+j+2:]))
				replacement = append(replacement, line[:i]...)
				replacement = append(replacement, line[i+j+2:]...)
				// Trace("line %d mutation %q -> %q", lineNum, line, replacement)
				line = replacement
			} else {
				inMultiLineComment = true
				continue ReadLoop
			}
		}

		if line[0] != '<' {
			Trace("compose: unhandled line %d, starts: %v", lineNum, line[0])
			counts.unhandled += 1
			continue
		}
		// There doesn't, apparently, need to be space between <keys>, so this whole logic needs a rework.
		// As of 2023-09-13, this affects one multi-key sequence, which has a dead_ element anyway, so
		// not yet breaking.
		// FIXME: rewrite this
		fields := bytes.Fields(line)
		indexColon := -1
		var indexReplacement int
		for i := range fields {
			if bytes.Equal(fields[i], []byte{':'}) {
				indexColon = i
			} else if bytes.HasSuffix(fields[i], []byte{':'}) {
				f2 := make([][]byte, i+1, len(fields)+1)
				if i > 1 {
					copy(f2, fields[:i])
				}
				f2[i] = fields[i][:len(fields[i])-1] // drop the trailing colon
				f2 = append(f2, []byte{':'})
				if len(fields) > i+1 {
					f2 = append(f2, fields[i+1:]...)
				}
				fields = f2
				indexColon = i + 1
			} else {
				continue
			}
			if len(fields) < indexColon+2 {
				Trace("compose: malformed line %d, nothing after colon", lineNum)
				counts.malformed += 1
				continue ReadLoop
			}
			indexReplacement = indexColon + 1
			break

		}
		if indexColon < 0 {
			Trace("compose: malformed line %d, no colon present", lineNum)
			counts.malformed += 1
			continue
		}
		if bytes.Equal(fields[0], []byte("<Multi_key>")) {
			counts.compose += 1
			outRuneQuoted := fields[indexReplacement]
			if bytes.Equal(outRuneQuoted, []byte{'"'}) && len(fields) >= indexReplacement+2 && bytes.Equal(fields[indexReplacement+1], []byte{'"'}) {
				// This doesn't account for multiple spaces, or tabs, but it's ... probably okay?  FIXME
				outRuneQuoted = []byte(`" "`)
			}
			if cs, ok := makeComposeSet(lineNum, &counts, fields[:indexColon], outRuneQuoted); ok {
				results = append(results, cs)
			}
			// makeComposeSet should Trace any failures
		} else if bytes.HasPrefix(fields[0], []byte("<dead_")) {
			counts.dead += 1
		} else if bytes.Equal(fields[0], []byte("<Greek_accentdieresis>")) {
			// equivalent to XK_dead_diaeresis
			counts.dead += 1
		} else if indexColon == 1 {
			counts.alias += 1
		} else {
			Trace("other: %d: %v", lineNum, string(line))
			counts.other += 1
		}

	}

	Trace("compose: lines: %d\tcomposes: %d", lineNum, counts.compose)
	Trace("compose: deads: %d\tother: %d\taliases: %d", counts.dead, counts.other, counts.alias)
	Trace("compose: multi-runes: %d\trawUnicodeIn: %d", counts.multiRune, counts.rawUnicodeIn)
	Trace("unhandled: %d\tmalformed: %d", counts.unhandled, counts.malformed)

	return results, nil
}

type composeSet struct {
	out rune
	in  string
}

type ComposeByRune []composeSet

func (a ComposeByRune) Len() int           { return len(a) }
func (a ComposeByRune) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ComposeByRune) Less(i, j int) bool { return a[i].out < a[j].out }

func normalizeComposes(in []composeSet) (byRune map[rune][]composeSet, orderedKeys []rune) {
	sort.Sort(ComposeByRune(in))
	orderedKeys = make([]rune, 0, len(in))
	byRune = make(map[rune][]composeSet, len(in))
	prevRune := rune(0)
	for _, item := range in {
		if item.out == prevRune {
			byRune[item.out] = append(byRune[item.out], item)
			continue
		}
		orderedKeys = append(orderedKeys, item.out)
		byRune[item.out] = []composeSet{item}
		prevRune = item.out
	}
	return
}

func makeComposeSet(lineNum int, counts *handleCounts, keysyms [][]byte, output []byte) (composeSet, bool) {
	if output[0] != '"' || output[len(output)-1] != '"' {
		Trace("compose line %d output string has unhandled quoting: %q", lineNum, string(output))
		return composeSet{}, false
	}
	if len(output) < 3 {
		Trace("compose line %d output too short [bytes %v]", lineNum, output)
		return composeSet{}, false
	}
	output = output[1 : len(output)-1]

	outLen := utf8.RuneCount(output)
	switch outLen {
	case 1:
	case 0:
		Trace("compose line %d missing output string", lineNum)
	default:
		// Trace("compose line %d makes multi-rune output, skipping (%q)", lineNum, string(output))
		counts.multiRune += 1
		return composeSet{}, false
	}

	r, _ := utf8.DecodeRune(output)
	if r == utf8.RuneError {
		Trace("compose line %d fails to decode a rune from bytes %v", lineNum, output)
		return composeSet{}, false
	}

	input, ok := makeSequenceRepr(lineNum, counts, keysyms[1:]) // drop the Multi_key
	if !ok {
		return composeSet{}, false
	}

	return composeSet{out: r, in: input}, true
}

func makeSequenceRepr(lineNum int, counts *handleCounts, keysyms [][]byte) (string, bool) {
	parts := make([]string, len(keysyms))
	for i := range keysyms {
		reportIndex := i + 2 // 1-based, starting with elided Multi_key
		if len(keysyms[i]) < 3 {
			Trace("compose line %d input key %d too short", lineNum, reportIndex)
			return "", false
		}
		indexLast := len(keysyms[i]) - 1
		if keysyms[i][0] != '<' || keysyms[i][indexLast] != '>' {
			Trace("compose line %d input key %d unhandled, bytes: %v", lineNum, reportIndex, keysyms[i])
			return "", false
		}
		// All keysyms have US-ASCII names
		if len(keysyms[i]) == 3 {
			parts[i] = string([]byte{keysyms[i][1]})
			continue
		}
		keysymName := string(keysyms[i][1:indexLast])
		if known, ok := keysymsToRuneString[keysymName]; ok {
			parts[i] = known
			continue
		}
		if keysymName[0] == 'U' && (len(keysymName) == 5 || len(keysymName) == 6) {
			counts.rawUnicodeIn += 1
			return "", false
		}
		if strings.HasPrefix(keysymName, "dead_") {
			counts.dead += 1
			return "", false
		}
		if strings.HasPrefix(keysymName, "KP_") {
			// how would I represent these tersely?
			counts.unhandled += 1
			return "", false
		}
		Trace("compose line %d input key %d unhandled: %q", lineNum, reportIndex, keysymName)
		counts.unhandled += 1
		return "", false
	}
	return strings.Join(parts, ""), true
}

var keysymsToRuneString map[string]string

func init() {
	// see keysymdef.h
	// well this grew more than expected, there's a lot of non-ASCII compose sequence inputs
	keysymsToRuneString = map[string]string{
		"space":        "␠",
		"exclam":       "!",
		"quotedbl":     "\"",
		"numbersign":   "#",
		"dollar":       "$",
		"percent":      "%",
		"ampersand":    "&",
		"apostrophe":   "'",
		"parenleft":    "(",
		"parenright":   ")",
		"asterisk":     "*",
		"plus":         "+",
		"comma":        ",",
		"minus":        "-",
		"period":       ".",
		"slash":        "/",
		"colon":        ":",
		"semicolon":    ";",
		"less":         "<",
		"equal":        "=",
		"greater":      ">",
		"question":     "?",
		"at":           "@",
		"bracketleft":  "[",
		"backslash":    "\\",
		"bracketright": "]",
		"asciicircum":  "^",
		"underscore":   "_",
		"grave":        "`",
		"braceleft":    "{",
		"bar":          "|",
		"braceright":   "}",
		"asciitilde":   "~",

		"Tab":        "\t",
		"underbar":   "_",
		"breve":      "˘",
		"EZH":        "Ʒ",
		"ezh":        "ʒ",
		"leftcaret":  "<", // what's the difference between this and XK_less ?  Looks to be a different key (+0xb00) but otherwise the same
		"rightcaret": ">",
		"leftshoe":   "⊂",
		"rightshoe":  "⊃",
		"lefttack":   "⊣",
		"righttack":  "⊢",

		"abreve":  "ă",
		"Abreve":  "Ă",
		"emacron": "ē",
		"Emacron": "Ē",
		"ohorn":   "ơ",
		"Ohorn":   "Ơ",
		"omacron": "ō",
		"Omacron": "Ō",
		"sacute":  "ś",
		"Sacute":  "Ś",
		"scaron":  "š",
		"Scaron":  "Š",
		"uhorn":   "ư",
		"umacron": "ū",
		"Umacron": "Ū",
		"utilde":  "ũ",

		// vim friend applied to the next blocks:
		// :'a,'bs@^#define XK_\([^[:space:]]\+\)[^/]\+/\* U+\([0-9A-F]\+\) .*@\="  \"".submatch(1)."\": \"".nr2char('0x'.submatch(2), 1)."\","@

		"lessthanequal":     "≤",
		"notequal":          "≠",
		"greaterthanequal":  "≥",
		"integral":          "∫",
		"therefore":         "∴",
		"variation":         "∝",
		"infinity":          "∞",
		"nabla":             "∇",
		"approximate":       "∼",
		"similarequal":      "≃",
		"ifonlyif":          "⇔",
		"implies":           "⇒",
		"identical":         "≡",
		"radical":           "√",
		"includedin":        "⊂",
		"includes":          "⊃",
		"intersection":      "∩",
		"union":             "∪",
		"logicaland":        "∧",
		"logicalor":         "∨",
		"partialderivative": "∂",
		"function":          "ƒ",
		"leftarrow":         "←",
		"uparrow":           "↑",
		"rightarrow":        "→",
		"downarrow":         "↓",

		"nobreakspace":   " ",
		"exclamdown":     "¡",
		"cent":           "¢",
		"sterling":       "£",
		"currency":       "¤",
		"yen":            "¥",
		"brokenbar":      "¦",
		"section":        "§",
		"diaeresis":      "¨",
		"copyright":      "©",
		"ordfeminine":    "ª",
		"guillemotleft":  "«",
		"notsign":        "¬",
		"hyphen":         "­",
		"registered":     "®",
		"macron":         "¯",
		"degree":         "°",
		"plusminus":      "±",
		"twosuperior":    "²",
		"threesuperior":  "³",
		"acute":          "´",
		"mu":             "µ",
		"paragraph":      "¶",
		"periodcentered": "·",
		"cedilla":        "¸",
		"onesuperior":    "¹",
		"masculine":      "º",
		"guillemotright": "»",
		"onequarter":     "¼",
		"onehalf":        "½",
		"threequarters":  "¾",
		"questiondown":   "¿",
		"Agrave":         "À",
		"Aacute":         "Á",
		"Acircumflex":    "Â",
		"Atilde":         "Ã",
		"Adiaeresis":     "Ä",
		"Aring":          "Å",
		"AE":             "Æ",
		"Ccedilla":       "Ç",
		"Egrave":         "È",
		"Eacute":         "É",
		"Ecircumflex":    "Ê",
		"Ediaeresis":     "Ë",
		"Igrave":         "Ì",
		"Iacute":         "Í",
		"Icircumflex":    "Î",
		"Idiaeresis":     "Ï",
		"ETH":            "Ð",
		"Ntilde":         "Ñ",
		"Ograve":         "Ò",
		"Oacute":         "Ó",
		"Ocircumflex":    "Ô",
		"Otilde":         "Õ",
		"Odiaeresis":     "Ö",
		"multiply":       "×",
		"Oslash":         "Ø",
		"Ooblique":       "Ø",
		"Ugrave":         "Ù",
		"Uacute":         "Ú",
		"Ucircumflex":    "Û",
		"Udiaeresis":     "Ü",
		"Yacute":         "Ý",
		"THORN":          "Þ",
		"ssharp":         "ß",
		"agrave":         "à",
		"aacute":         "á",
		"acircumflex":    "â",
		"atilde":         "ã",
		"adiaeresis":     "ä",
		"aring":          "å",
		"ae":             "æ",
		"ccedilla":       "ç",
		"egrave":         "è",
		"eacute":         "é",
		"ecircumflex":    "ê",
		"ediaeresis":     "ë",
		"igrave":         "ì",
		"iacute":         "í",
		"icircumflex":    "î",
		"idiaeresis":     "ï",
		"eth":            "ð",
		"ntilde":         "ñ",
		"ograve":         "ò",
		"oacute":         "ó",
		"ocircumflex":    "ô",
		"otilde":         "õ",
		"odiaeresis":     "ö",
		"division":       "÷",
		"oslash":         "ø",
		"ooblique":       "ø",
		"ugrave":         "ù",
		"uacute":         "ú",
		"ucircumflex":    "û",
		"udiaeresis":     "ü",
		"yacute":         "ý",
		"thorn":          "þ",
		"ydiaeresis":     "ÿ",

		"Greek_ALPHA":           "Α",
		"Greek_BETA":            "Β",
		"Greek_GAMMA":           "Γ",
		"Greek_DELTA":           "Δ",
		"Greek_EPSILON":         "Ε",
		"Greek_ZETA":            "Ζ",
		"Greek_ETA":             "Η",
		"Greek_THETA":           "Θ",
		"Greek_IOTA":            "Ι",
		"Greek_KAPPA":           "Κ",
		"Greek_LAMDA":           "Λ",
		"Greek_LAMBDA":          "Λ",
		"Greek_MU":              "Μ",
		"Greek_NU":              "Ν",
		"Greek_XI":              "Ξ",
		"Greek_OMICRON":         "Ο",
		"Greek_PI":              "Π",
		"Greek_RHO":             "Ρ",
		"Greek_SIGMA":           "Σ",
		"Greek_TAU":             "Τ",
		"Greek_UPSILON":         "Υ",
		"Greek_PHI":             "Φ",
		"Greek_CHI":             "Χ",
		"Greek_PSI":             "Ψ",
		"Greek_OMEGA":           "Ω",
		"Greek_alpha":           "α",
		"Greek_beta":            "β",
		"Greek_gamma":           "γ",
		"Greek_delta":           "δ",
		"Greek_epsilon":         "ε",
		"Greek_zeta":            "ζ",
		"Greek_eta":             "η",
		"Greek_theta":           "θ",
		"Greek_iota":            "ι",
		"Greek_kappa":           "κ",
		"Greek_lamda":           "λ",
		"Greek_lambda":          "λ",
		"Greek_mu":              "μ",
		"Greek_nu":              "ν",
		"Greek_xi":              "ξ",
		"Greek_omicron":         "ο",
		"Greek_pi":              "π",
		"Greek_rho":             "ρ",
		"Greek_sigma":           "σ",
		"Greek_finalsmallsigma": "ς",
		"Greek_tau":             "τ",
		"Greek_upsilon":         "υ",
		"Greek_phi":             "φ",
		"Greek_chi":             "χ",
		"Greek_psi":             "ψ",
		"Greek_omega":           "ω",

		"Greek_alphaaccent":     "ά",
		"Greek_etaaccent":       "ή",
		"Greek_iotadieresis":    "ϊ",
		"Greek_omegaaccent":     "ώ",
		"Greek_upsilondieresis": "ϋ",

		"kana_fullstop":       "。",
		"kana_openingbracket": "「",
		"kana_closingbracket": "」",
		"kana_comma":          "、",
		"kana_conjunctive":    "・",
		"kana_WO":             "ヲ",
		"kana_a":              "ァ",
		"kana_i":              "ィ",
		"kana_u":              "ゥ",
		"kana_e":              "ェ",
		"kana_o":              "ォ",
		"kana_ya":             "ャ",
		"kana_yu":             "ュ",
		"kana_yo":             "ョ",
		"kana_tsu":            "ッ",
		"prolongedsound":      "ー",
		"kana_A":              "ア",
		"kana_I":              "イ",
		"kana_U":              "ウ",
		"kana_E":              "エ",
		"kana_O":              "オ",
		"kana_KA":             "カ",
		"kana_KI":             "キ",
		"kana_KU":             "ク",
		"kana_KE":             "ケ",
		"kana_KO":             "コ",
		"kana_SA":             "サ",
		"kana_SHI":            "シ",
		"kana_SU":             "ス",
		"kana_SE":             "セ",
		"kana_SO":             "ソ",
		"kana_TA":             "タ",
		"kana_CHI":            "チ",
		"kana_TSU":            "ツ",
		"kana_TE":             "テ",
		"kana_TO":             "ト",
		"kana_NA":             "ナ",
		"kana_NI":             "ニ",
		"kana_NU":             "ヌ",
		"kana_NE":             "ネ",
		"kana_NO":             "ノ",
		"kana_HA":             "ハ",
		"kana_HI":             "ヒ",
		"kana_FU":             "フ",
		"kana_HE":             "ヘ",
		"kana_HO":             "ホ",
		"kana_MA":             "マ",
		"kana_MI":             "ミ",
		"kana_MU":             "ム",
		"kana_ME":             "メ",
		"kana_MO":             "モ",
		"kana_YA":             "ヤ",
		"kana_YU":             "ユ",
		"kana_YO":             "ヨ",
		"kana_RA":             "ラ",
		"kana_RI":             "リ",
		"kana_RU":             "ル",
		"kana_RE":             "レ",
		"kana_RO":             "ロ",
		"kana_WA":             "ワ",
		"kana_N":              "ン",

		"Cyrillic_yu":       "ю",
		"Cyrillic_a":        "а",
		"Cyrillic_be":       "б",
		"Cyrillic_tse":      "ц",
		"Cyrillic_de":       "д",
		"Cyrillic_ie":       "е",
		"Cyrillic_ef":       "ф",
		"Cyrillic_ghe":      "г",
		"Cyrillic_ha":       "х",
		"Cyrillic_i":        "и",
		"Cyrillic_shorti":   "й",
		"Cyrillic_ka":       "к",
		"Cyrillic_el":       "л",
		"Cyrillic_em":       "м",
		"Cyrillic_en":       "н",
		"Cyrillic_o":        "о",
		"Cyrillic_pe":       "п",
		"Cyrillic_ya":       "я",
		"Cyrillic_er":       "р",
		"Cyrillic_es":       "с",
		"Cyrillic_te":       "т",
		"Cyrillic_u":        "у",
		"Cyrillic_zhe":      "ж",
		"Cyrillic_ve":       "в",
		"Cyrillic_softsign": "ь",
		"Cyrillic_yeru":     "ы",
		"Cyrillic_ze":       "з",
		"Cyrillic_sha":      "ш",
		"Cyrillic_e":        "э",
		"Cyrillic_shcha":    "щ",
		"Cyrillic_che":      "ч",
		"Cyrillic_hardsign": "ъ",
		"Cyrillic_YU":       "Ю",
		"Cyrillic_A":        "А",
		"Cyrillic_BE":       "Б",
		"Cyrillic_TSE":      "Ц",
		"Cyrillic_DE":       "Д",
		"Cyrillic_IE":       "Е",
		"Cyrillic_EF":       "Ф",
		"Cyrillic_GHE":      "Г",
		"Cyrillic_HA":       "Х",
		"Cyrillic_I":        "И",
		"Cyrillic_SHORTI":   "Й",
		"Cyrillic_KA":       "К",
		"Cyrillic_EL":       "Л",
		"Cyrillic_EM":       "М",
		"Cyrillic_EN":       "Н",
		"Cyrillic_O":        "О",
		"Cyrillic_PE":       "П",
		"Cyrillic_YA":       "Я",
		"Cyrillic_ER":       "Р",
		"Cyrillic_ES":       "С",
		"Cyrillic_TE":       "Т",
		"Cyrillic_U":        "У",
		"Cyrillic_ZHE":      "Ж",
		"Cyrillic_VE":       "В",
		"Cyrillic_SOFTSIGN": "Ь",
		"Cyrillic_YERU":     "Ы",
		"Cyrillic_ZE":       "З",
		"Cyrillic_SHA":      "Ш",
		"Cyrillic_E":        "Э",
		"Cyrillic_SHCHA":    "Щ",
		"Cyrillic_CHE":      "Ч",
		"Cyrillic_HARDSIGN": "Ъ",
		"Ukrainian_I":       "І",
		"Ukrainian_i":       "і",
	}
}

func reformatFile(fn string) error {
	cmd := exec.Command("go", "fmt", fn)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	return cmd.Run()
}

func haveDir(dirname string) bool {
	st, err := os.Stat(dirname)
	if err != nil {
		if !os.IsNotExist(err) {
			Warn("failed to stat %q: %s", dirname, err)
		}
		return false
	}
	if st.Mode().IsDir() {
		return true
	}
	Warn("not a directory: %q (%s)", dirname, st.Mode())
	return false
}

func Trace(template string, params ...interface{}) {
	fmt.Fprintf(os.Stderr, "%s: ", filepath.Base(os.Args[0]))
	fmt.Fprintf(os.Stderr, template, params...)
	fmt.Fprintln(os.Stderr)
}

func Warn(template string, params ...interface{}) {
	Trace(template, params...)
	warningCount++
}

func Die(template string, params ...interface{}) {
	Warn(template, params...)
	os.Exit(1)
}
